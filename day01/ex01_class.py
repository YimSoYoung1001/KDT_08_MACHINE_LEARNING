"""
#클래스
- 구성요소 : 메서드 (함수) + 속성/필드 (변수)
- 구성 요소 종류
    - 클래스 변수 / 클래스 메서드 : 인스턴스 생성없이 사용가능, cls
    - 인스턴스 변수 / 인스턴스 메서드 : 반드시 인스턴스 생성해야만 사용가능, self

    class A
	def __new__(cls)
	def __init__(self)

#객체 / 인스턴스

#오버라이딩 => 반드시 상속 관계
#오버로딩 => 함수 이름 동일 & 매개변수 다르게 생성
#상속 => class A(B, C, D) : pass
- 다중 상속
"""

# 클래스 생성 (1) -------------------------------------------------------------------------------------
# - 구성 요소 : 속성 + 메서드 => 모두 없는 클래스
# - 기본 상속 : Object ==> __속성명__, __메서드명__()
#             (인스턴스 생성시 이것들이 기본적으로 상속된다)
# ---------------------------------------------------------------------------------------------------
class A:
    pass

# 클래스 생성 (2) -------------------------------------------------------------------------------------
# - 구성 요소 : 속성 + 메서드 => 인스턴스 변수와 메서드
# - 기본 상속 : Object ==> __속성명__, __메서드명__()
# ---------------------------------------------------------------------------------------------------
class B:
    # 인스턴스 객체 생성 및 속성 초기화 메서드
    def __init__(self, num, name):
        #self로 지정된 힙 메모리 주소에서부터 속성 저장
        self.num = num
        self.name = name

    # 인스턴스 메서드 (self가 붙는다.)
    def printInfo(self):
        print(f"num : {self.num}")
        print(f"name : {self.name}")

    # 연산자 맵핑 메서드 구현
    def __add__(self, other):
        print('__add__')
        return self.num + other.num
    def __sub__(self, other):
        return self.num - other.num

# 클래스 생성 (3) -------------------------------------------------------------------------------------
# - 구성 요소 : 속성 + 메서드 => 인스턴스 변수와 메서드
# - 기본 상속 : Object ==> __속성명__, __메서드명__()
# ---------------------------------------------------------------------------------------------------
class C:
    # 클래스 변수 => C 클래스로 생성된 모든 인스턴스에서 공유
    #           => 인스턴스 생성 없이 사용 가능
    loc = 'Daegu'

    # 인스턴스 객체 생성 및 속성 초기화 메서드
    def __init__(self, num, name):
        #self로 지정된 힙 메모리 주소에서부터 속성 저장
        self.num = num
        self.name = name

    # 인스턴스 메서드 (self가 붙는다.)
    def printInfo(self):
        print(f"num : {self.num}")
        print(f"name : {self.name}")




# 클래스 생성 (4) -------------------------------------------------------------------------------------
# - 구성 요소 : 속성 + 메서드 => 클래스 변수와 메서드
# - 기본 상속 : Object ==> __속성명__, __메서드명__()
# ---------------------------------------------------------------------------------------------------
class DCalc:
    # 클래스 변수 => C 클래스로 생성된 모든 인스턴스에서 공유
    #           => 인스턴스 생성 없이 사용 가능
    name = 'CASIO'

    # 클래스 메서드
    @classmethod
    def addNum(cls, a, b):        #cls => 클래스 정보
        #print(DCalc.name)        #데코레이터를 쓴다면 이렇게 클래스명으로 바로 접근가능하다.
        print(cls.name)
        print(cls.addNum(a,b))
        return a + b

    #@classmethod
    def minusNum(cls, a, b):
        return a - b

# 일반 함수 -----------------------------------------------------------------------------------------
'''
def test(a, b):
    print(a,b)

def test(a, b, c):
    print(a, b, c)

test(10, 20)  #에러가 발생, 같은 이름의 함수라면 뒤에 놈이 적용됨
test(10, 20, 30)
'''



# 객체 / 인스턴스 생성 ---------------------------------------------------------------------------------
# => 생성 함수 : 클래스 이름 (__init__메서드 매개변수)
# => A ()
# ---------------------------------------------------------------------------------------------------
a1 = A() #메서드 매개변수 없음
b1 = B(100, "BB") #메서드 매개변수 있음
b2 = B(30, 'B2')
#c1 = C(1000, 'CCC') #메서드 매개변수 있음

# 객체/인스턴스의 연산 ----------------------------------------------------------------------------------
print('ABC' + '123')
print([1,2,3] + [10, 20, 30])
print('------------', b1 + b2)  #지원안한다고 함
print('------------', b1 - b2)


# 객체 / 인스턴스의 속성/메서드 사용 ---------------------------------------------------------------------------------
# => 사용 방법 : 객체/인스턴스 변수명.속성
#              객체/인스턴스 변수명.메서드()
# --------------------------------------------------------------------------------------------------------------
# print("A 인스턴스 a1의 속성과 메서드 =>", a1.__dict__) # a1 인스턴스 안에 가지고 있는 속성과 메서드가 나옴 (현재 없으니까 blank)
# print('-'*50)
# print("A 인스턴스 a1의 속성과 메서드 =>", a1.__dir__())
# print('-'*50)
# print("A 클래스의 속성과 메서드 =>", A.__dict__)      #A 클래스 안에 가지고 있는 속성과 메서드가 나옴


# 객체 / 인스턴스의 속성/메서드 사용 ---------------------------------------------------------------------------------
# => 사용 방법 : 객체/인스턴스 변수명.속성
#              객체/인스턴스 변수명.메서드()
# --------------------------------------------------------------------------------------------------------------
# print("B 인스턴스 b1의 속성과 메서드 =>", b1.__dict__) # 인스턴스가 가진 속성만 보여줌
# print('-'*50)
# print("B 인스턴스 b1의 속성과 메서드 =>", b1.__dir__()) # 인스턴스가 가진 속성 + 객체가 가진 속성
# print('-'*50)
# print("B 클래스의 속성과 메서드 =>", B.__dict__)      # 자기가 가지고 있는 속성 모두 보여줌
# ㄴ 결과값 중에서,,,
# 'printInfo': <function B.printInfo at 0x0000021BBA9B3700> => 클래스 안에 생성된 함수가 가지고 있는 주소값이 찍힌다.

# 인스턴스 메서드 사용
#c1.printInfo()

# 인스턴스 속성 사용
#print(c1.name)

# 클래스 속성 사용
#print("loc => ", C.loc)      #이렇게 2가지 방식으로 쓸 수 있다.

# 인스턴스 메서드는 클래스명으로 사용 불가!! => self 즉 인스턴스 주소 및 정보 없음
#C.printInfo()

# 클래스 송성 및 메서드 사용
#print(f"DCalc.name : {DCalc.name}")
#print(f"DCalc.addNum(10, 20) : {DCalc.addNum(10, 20)}")
#print(f"DCalc.minusNum(10, 20) : {DCalc.minusNum(10, 20)}")   #데코레이터가 달려있지 않기 때문에 이거는 총 3개의 변수를 주어야 한다.


